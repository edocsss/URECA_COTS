package v1;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;

public final class OperationGroupManager 
{
	/**
	 * Stores all Operation Group objects to ease getting an OperationGroup object when the diagram is generated
	 * This ArrayList will not be changed at all after the OperationGroup objects are generated by the Parser object
	 * and stored inside this static variable
	 */
	private static ArrayList<OperationGroup> operationGroups = new ArrayList<OperationGroup> ();
	
	/**
	 * Return an OperationGroup object specified by the ID
	 * @param id	The ID of the OperationGroup to be returned
	 * @return		OperationGroup object with the correct ID
	 */
	public static OperationGroup getOperationGroupById (int id)
	{
		for (OperationGroup og: operationGroups)
		{
			if (og.getId() == id)
			{
				return og;
			}
		}
		
		return null;
	}
	
	/**
	 * Set this class static OperationGroups ArrayList
	 * @param og 	The OperationGroup ArrayList to store in this operationGroups variable
	 */
	public static void setOperationGroups (ArrayList<OperationGroup> og)
	{
		operationGroups = og;
	}
	
	/**
	 * Get the biggest size OperationGroup (the outermost OperationGroup of the parsed expression)
	 * The biggest group must be added last so this method return the last element
	 * 
	 * @return	An OperationGroup object which is the biggest one
	 */
	public static OperationGroup getBiggestOperationGroup ()
	{
		return operationGroups.get(operationGroups.size() - 1);
	}
	
	/**
	 * This method is the main method which decides where the line should be drawn, how long, the direction, etc.
	 * It uses a recursive call to analyze each single operand (like a DFS where one tree node is one operand)
	 * 
	 * How it works:
	 * <p>For every call, it checks whether it is a concurrent operation. If it is, then the process of drawing can be done
	 * as follows:
	 * <ul>
	 * <li>
	 * For every line drawn in Site 1 (meaning that it is the first operand and it is drawn to the right), draw the site 2 line
	 * as well (the line going upward).
	 * <ol> 
	 * 	<li>To know how many lines to draw, look for the depth of the second operand (Site 2 operation)</li>
	 * 	<li>If the depth is n, then it means there are n causal relation in Site 2 (REMEMBER: this is a 2D COTS)</li>
	 * </ol>
	 * </li>
	 * <li>
	 * After that, the coordPointer will go back to the origin where the concurrency happened before.
	 * </li>
	 * <li>
	 * From there, it will start drawing the other site with the same ways as before. The only difference is just the coordPointer
	 * does not trace back after drawing the last transformed line from Site 1.
	 * </li>
	 * 
	 * <p>
	 * If it is a causal relation:
	 * <ul>
	 * <li>
	 * Check whether the first operand is another OperationGroup or a single operand
	 * </li>
	 * <li>
	 * If it is an OperationGroup, do a recursive call
	 * </li>
	 * <li>
	 * If it is a single operand, draw the line to the right (we assume the first operand is always in site 1) and DO NOT MOVE
	 * BACK the coordPointer as this is a pure causality relation
	 * </li>
	 * <li>
	 * Check the second operand, and do the same thing
	 * </li>
	 * </ul>
	 * </p>
	 * <p>
	 * NOTE: It is impossible to find both first and second operand have a OperationGroup object!! This is a 2D COTS Generator!!
	 * </p>
	 * 
	 * <p>
	 * <b>IMPORTANT NOTE!!</b>
	 * The idea of recursively calling this method is to get the smallest operand possible, which is a single operand!!
	 * After this SINGLE OPERAND is found, start drawing the lines.
	 * </p>
	 * 
	 * @param o					An OperationGroup object from which the information is then analyzed
	 * @param d					A DrawLine object, to add the lines
	 * @param coordPointer		The pointer in the coordinate system
	 * @param n					An integer indicating how many lines needed to be drawn for the other site
	 * @param siteTwo			The direction the line is drawn (up or right)
	 */
	public static void generateDiagram (OperationGroup o, DrawLine d, Point2D.Double coordPointer, int n, ArrayList<Integer> id, boolean siteTwo)
	{
		// Temporary variable declaration
		OperationGroup og;
		Point2D.Double endPoint;
		COTSLine l;
		double[] pointerMovement = new double[] {0.0, 0.0}; // Keep track how far the coordPointer has moved
		int numLines = 1; // This keeps track the number of operations from the other site need to be drawn when doing one site
						  // If it is concurrent, at least there is 1 line from other site to be drawn
		ArrayList<Integer> IDList = new ArrayList<Integer> ();
		double offsetX, offsetY; // These two variables will be different depending on which site the line is drawn
		double traceBackX, traceBackY;
				
		// If it is a concurrent operation
		if (o.getConcurrency())
		{
			// Check whether second operand is another OperationGroup
			if (o.getSecondOperand() < 0)
			{
				og = getOperationGroupById(o.getSecondOperand());
				
				// Get the number of lines need to be drawn in Site 1
				numLines = og.getDepth();
				
				// For the purpose of labeling for the other site
				IDList = o.getOtherSiteID(IDList);
				Collections.sort(IDList);
			}
			else if (o.getSecondOperand() > 0)
			{
				IDList.add(o.getSecondOperand());
			}
			
			// If the first operand is also a OperationGroup
			if (o.getFirstOperand() < 0)
			{
				// Keep track where the coordPointer was before the concurrency happened (the interjunction between the two sites)
				traceBackX = coordPointer.x;
				traceBackY = coordPointer.y;
				
				// Retrieve the object
				og = OperationGroupManager.getOperationGroupById(o.getFirstOperand());
				og.setPrevConcurrency(true);
				generateDiagram(og, d, coordPointer, numLines, IDList, false);
				
				// Move back the pointer into the place where the interjunction of the two sites before the concurrency happened
				coordPointer.setLocation(traceBackX, traceBackY);
			}
			// If the first operand is a single operand, draw directly 
			else if (o.getFirstOperand() > 0)
			{
				// The first operand of a concurrent operation must be in the first site
				// Draw to the right -> change the X value
				offsetX = DiagramGenerator.POINTER_OFFSET_X;
				offsetY = 0.0;
				
				// Decide where the line will end
				endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
				
				// Construct the line
				l = new COTSLine(coordPointer, endPoint, o.getFirstOperand());
				
				// Add the line to the list
				d.addLine(l);
				
				// Update the coordPointer for the purpose of next line creation
				coordPointer.setLocation(endPoint);
				
				// Keep track how far the pointer has moved
				pointerMovement[0] += offsetX;
				pointerMovement[1] += offsetY;
				
				// Update the offset
				// This offset will be used to draw the OTHER SITE lines (in this case is Site 2 and therefore it
				// will be drawn upwards)
				offsetX = 0.0;
				offsetY = DiagramGenerator.POINTER_OFFSET_Y;
				
				// Construct and add the lines of the SITE 2
				for (int i = 0; i < numLines; i++)
				{
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, IDList.get(i));
					l.setDashed(true);
					d.addLine(l);
					
					// Update the pointer and how far it has moved
					coordPointer.setLocation(endPoint);
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
				}
				
				// Trace back the coordPointer so that it goes back to where the concurrency starts
				// It is to prepare to draw the lines of SITE 2
				coordPointer.setLocation(coordPointer.x - pointerMovement[0], coordPointer.y - pointerMovement[1]);
			}
						
			// Reset the number of lines need to be drawn (this is for SITE 1 now)
			numLines = 1;
			IDList.clear();
			
			// Update the number of lines from SITE 1 which needs to be drawn while drawing the lines for SITE 2
			if (o.getFirstOperand() < 0)
			{
				og = getOperationGroupById(o.getFirstOperand());
				numLines = og.getDepth();
				
				// For the purpose of labeling for the other site
				IDList = o.getOtherSiteID(IDList);
				Collections.sort(IDList);
			}
			// To add the ID of the other site to the IDList
			else if (o.getFirstOperand() > 0)
			{
				IDList.add(o.getFirstOperand());
			}
			
			// If the second operand is also a OperationGroup
			if (o.getSecondOperand() < 0)
			{
				og = getOperationGroupById(o.getSecondOperand());
				og.setPrevConcurrency(true);
				generateDiagram(og, d, coordPointer, numLines, IDList, true);
			}
			// When the second operand is now only a SINGLE operand
			else if (o.getSecondOperand() > 0)
			{
				// Since this is SITE 2, the drawing of SITE 2's own operation is UPWARDS
				// That's why the Y is changed
				offsetX = 0.0;
				offsetY = DiagramGenerator.POINTER_OFFSET_Y;
				
				// Determine where the line ends and construct the line object
				endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
				l = new COTSLine(coordPointer, endPoint, o.getSecondOperand());
				
				// Add the line to the list of lines to be drawn
				d.addLine(l);
				
				// Update the coordPointer location
				coordPointer.setLocation(endPoint);
				
				// Keep track how far the coordPointer has moved
				pointerMovement[0] += offsetX;
				pointerMovement[1] += offsetY;
				
				// Update the offset to prepare drawing the other site's lines (SITE 1)
				offsetX = DiagramGenerator.POINTER_OFFSET_X;
				offsetY = 0.0;
				
				// Actually draws and add the lines from SITE 1
				for (int i = 0; i < numLines; i++)
				{
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, IDList.get(i));
					l.setDashed(true);
					d.addLine(l);
					
					// Update and prepare the coordPointer for the next drawing 
					coordPointer.setLocation(endPoint);
					
					// Keep track how far coordPointer has moved
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
				}
			}
		}
		else
		{
			// In case it is a causal relation, but it is called from a concurrent GroupOperation previously
			// It means that for each line drawn, it must draw the other site's lines
			if (o.getPrevConcurrency())
			{
				// Recursive call -> to get the smallest operand
				if (o.getFirstOperand() < 0)
				{
					og = getOperationGroupById(o.getFirstOperand());
					og.setPrevConcurrency(og.getPrevConcurrency());
					generateDiagram(og, d, coordPointer, n, id, siteTwo);
				}
				// If it is already the smallest operand, draw the line 
				else if (o.getFirstOperand() > 0)
				{
					// As this part of function (the causal relation part) can be called either by SITE 1 or SITE 2
					// We must determine which direction the line will be drawn
					
					// If drawing for SITE 2
					if (siteTwo)
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
					// Drawing for SITE 1
					else
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;
					}
					
					// Construct THAT SITE's line
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, o.getFirstOperand());
					
					// Add the line
					d.addLine(l);
					coordPointer.setLocation(endPoint);
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
					
					// Now, preparation for THE OTHER SITE's line drawing (it must be in the reverse direction than the current SITE)
					// That's why below is the swapping of the offset
					if (siteTwo)
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;	
					}
					else
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
										
					// Draw the lines from the other site
					for (int i = 0; i < n; i++)
					{
						endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);						
						l = new COTSLine(coordPointer, endPoint, id.get(i));
						l.setDashed(true);
						d.addLine(l);
						
						coordPointer.setLocation(endPoint);
						pointerMovement[0] += offsetX;
						pointerMovement[1] += offsetY;
					}
					
					// Trace back the coordPointer to the original place if and only if it is in the SITE 1
					// This goes back to the place before the line from SITE 2 is drawn when drawing SITE 1's lines
					if (!siteTwo)
					{
						coordPointer.setLocation(coordPointer.x, coordPointer.y - pointerMovement[1]);
						pointerMovement[1] = 0.0;
					}
				}
				
				// In the case of SITE 2 causal relation with previous concurrency = true
				// The checking is done as follows
				// 1. After the first operand is done, the last pointer is still on the tip of the lines created for SITE 1 (the transformed line)
				// 2. Therefore, we need to trace back to the point where the line should continue for SITE 2
				// 3. THIS ONLY WORKS WHEN DRAWING UPWARDS!!
				if (siteTwo)
				{
					// n * OFFSET_X means that there are n lines to be drawn from the other site, and per line has the width
					// of OFFSET_X
					coordPointer.setLocation(coordPointer.x - n * DiagramGenerator.POINTER_OFFSET_X, coordPointer.y);
				}
				
				// If the second operand is a OperationGroup
				if (o.getSecondOperand() < 0)
				{
					og = getOperationGroupById(o.getFirstOperand());
					og.setPrevConcurrency(og.getPrevConcurrency());
					generateDiagram(og, d, coordPointer, n, id, siteTwo);
				}
				else if (o.getSecondOperand() > 0)
				{
					// Setting up the direction of drawing
					if (siteTwo)
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
					else
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;
					}
					
					// Construct line, add line, keep track of coordPointer
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, o.getSecondOperand());
					
					d.addLine(l);
					coordPointer.setLocation(endPoint);
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
					
					// Setting up for drawing the other SITE's lines
					if (siteTwo)
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;
						
					}
					else
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
					
					// Actually drawing the other SITE's line
					for (int i = 0; i < n; i++)
					{
						endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
						l = new COTSLine(coordPointer, endPoint, id.get(i));
						l.setDashed(true);
						d.addLine(l);
						
						coordPointer.setLocation(endPoint);
						pointerMovement[0] += offsetX;
						pointerMovement[1] += offsetY;
					}
					
					// IF IT IS SITE 1: TRANSLATE BACK THE COORDPOINTER TO THE CORRECT POSITION AFTER DRAWING THE OTHER SITE'S
					// LINES (MOVE ALONG AXIS Y ONLY) because the drawing of SITE 1's original line is to the right
					// After drawing the other site's lines, the point is not in the main line where the original line is being
					// drawn
					if (!siteTwo)
					{
						coordPointer.setLocation(coordPointer.x, coordPointer.y - pointerMovement[1]);
						pointerMovement[1] = 0.0;
					}
				}
			}
			// If it is just a usual causal relation (no concurrency previously)
			else
			{
				// Getting the smallest operand
				if (o.getFirstOperand() < 0)
				{
					og = getOperationGroupById(o.getFirstOperand());
					og.setPrevConcurrency(o.getPrevConcurrency());
					generateDiagram(og, d, coordPointer, n, null, siteTwo);
				}
				// If it is the smallest operand, then start drawing ONLY THIS SITE!! (because there is no concurrency)
				else if (o.getFirstOperand() > 0)
				{
					// Setting up the direction of drawing
					if (siteTwo)
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
					else
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;
					}
					
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, o.getFirstOperand());
					
					d.addLine(l);
					coordPointer.setLocation(endPoint);
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
				}
				
				// Checking for second operand
				if (o.getSecondOperand() < 0)
				{
					og = getOperationGroupById(o.getSecondOperand());
					og.setPrevConcurrency(o.getPrevConcurrency());
					generateDiagram(og, d, coordPointer, n, null, siteTwo);
				}
					
				// Drawing the second operand
				else if (o.getSecondOperand() > 0)
				{
					if (siteTwo)
					{
						offsetX = 0.0;
						offsetY = DiagramGenerator.POINTER_OFFSET_Y;
					}
					else
					{
						offsetX = DiagramGenerator.POINTER_OFFSET_X;
						offsetY = 0.0;
					}
					
					endPoint = new Point2D.Double(coordPointer.x + offsetX, coordPointer.y + offsetY);
					l = new COTSLine(coordPointer, endPoint, o.getSecondOperand());
					d.addLine(l);
					
					coordPointer.setLocation(endPoint);
					pointerMovement[0] += offsetX;
					pointerMovement[1] += offsetY;
				}
			}
		}
	}
}
